[åˆé›† \- å‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨(22\)](https://github.com)[1\.å‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨ï¼ˆ2ï¼‰\- å‚è€ƒçº¿ã€svgã€gifå›¾ç‰‡åŠ è½½04\-06](https://github.com/xachary/p/18117864)[2\.å‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨ï¼ˆ1ï¼‰\- æ— é™ç”»å¸ƒã€æ¯”ä¾‹å°º04\-05](https://github.com/xachary/p/18115479)[3\.å‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨ï¼ˆ4ï¼‰\- å¿«æ·é”®ç§»åŠ¨å…ƒç´ 04\-11](https://github.com/xachary/p/18130149)[4\.å‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨ï¼ˆ3ï¼‰\- å•é€‰ã€å¤šé€‰ã€é€‰æ‹©æ¡†04\-10](https://github.com/xachary/p/18127777)[5\.å‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨ï¼ˆ5ï¼‰\- ç£è´´æ•ˆæœ04\-16](https://github.com/xachary/p/18139413)[6\.å‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨ï¼ˆ6ï¼‰\- å¤åˆ¶ç²˜è´´ã€åˆ é™¤ã€ä½ç½®ã€zIndexè°ƒæ•´04\-20](https://github.com/xachary/p/18147185)[7\.å‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨ï¼ˆ7ï¼‰\- å¯¼å…¥å¯¼å‡ºã€ä¸Šä¸€æ­¥ã€ä¸‹ä¸€æ­¥04\-24](https://github.com/xachary/p/18156521)[8\.å‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨ï¼ˆ8ï¼‰\- é¢„è§ˆæ¡†04\-30](https://github.com/xachary/p/18168732)[9\.å‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨ï¼ˆ9ï¼‰\- å¦å­˜ä¸ºSVG05\-07](https://github.com/xachary/p/18178115)[10\.å‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨ï¼ˆ10ï¼‰\- å¯¹é½çº¿05\-11](https://github.com/xachary/p/18187292)[11\.å‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨ï¼ˆ11ï¼‰\- å¯¹é½æ•ˆæœ05\-18](https://github.com/xachary/p/18199767)[12\.å‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨ï¼ˆ12ï¼‰\- è¿æ¥çº¿ \- ç›´çº¿06\-02](https://github.com/xachary/p/18226877)[13\.å‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨ï¼ˆ13ï¼‰\- æŠ˜çº¿ \- æœ€ä¼˜è·¯å¾„åº”ç”¨ã€æ€è·¯ç¯‡ã€‘06\-08](https://github.com/xachary/p/18238704)[14\.å‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨ï¼ˆ14ï¼‰\- æŠ˜çº¿ \- æœ€ä¼˜è·¯å¾„åº”ç”¨ã€ä»£ç ç¯‡ã€‘06\-11](https://github.com/xachary/p/18241664):[FlowerCloudæœºåœº](https://hushicha.org)[15\.å‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨ï¼ˆ15ï¼‰\- è‡ªå®šä¹‰è¿æ¥ç‚¹ã€è¿æ¥ä¼˜åŒ–06\-14](https://github.com/xachary/p/18248511)[16\.å‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨ï¼ˆ16ï¼‰\- æ—‹è½¬å¯¹é½ã€è§¦æ‘¸æ¿æ“ä½œçš„ä¼˜åŒ–06\-17](https://github.com/xachary/p/18253370)[17\.å‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨ï¼ˆ17ï¼‰\- ç´ æåµŒå¥— \- ç”Ÿæˆé˜¶æ®µ07\-19](https://github.com/xachary/p/18312538)[18\.å‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨ï¼ˆ18ï¼‰\- ç´ æåµŒå¥— \- åŠ è½½é˜¶æ®µ07\-22](https://github.com/xachary/p/18316657)[19\.å‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨ï¼ˆ19ï¼‰\- è¿æ¥çº¿ \- ç›´çº¿ã€æŠ˜çº¿08\-01](https://github.com/xachary/p/18337764)[20\.å‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨ï¼ˆ20ï¼‰\- æ€§èƒ½ä¼˜åŒ–ã€UI ç¾åŒ–08\-08](https://github.com/xachary/p/18348696)[21\.å‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨ï¼ˆ21ï¼‰\- ç»˜åˆ¶å›¾å½¢ï¼ˆæ¤­åœ†ï¼‰08\-20](https://github.com/xachary/p/18370023)22\.å‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨ï¼ˆ22ï¼‰\- ç»˜åˆ¶å›¾å½¢ï¼ˆçŸ©å½¢ã€ç›´çº¿ã€æŠ˜çº¿ï¼‰09\-10æ”¶èµ·
æœ¬ç« åˆ†äº«ä¸€ä¸‹å¦‚ä½•ä½¿ç”¨ Konva ç»˜åˆ¶åŸºç¡€å›¾å½¢ï¼šçŸ©å½¢ã€ç›´çº¿ã€æŠ˜çº¿ï¼Œå¸Œæœ›å¤§å®¶ç»§ç»­å…³æ³¨å’Œæ”¯æŒå“ˆï¼



> è¯·å¤§å®¶åŠ¨åŠ¨å°æ‰‹ï¼Œç»™æˆ‘ä¸€ä¸ªå…è´¹çš„ Star å§\~
> 
> 
> å¤§å®¶å¦‚æœå‘ç°äº† Bugï¼Œæ¬¢è¿æ¥æ Issue å“Ÿ\~
> 
> 
> [githubæºç ](https://github.com)
> 
> 
> [giteeæºç ](https://github.com)
> 
> 
> [ç¤ºä¾‹åœ°å€](https://github.com)


## çŸ©å½¢


å…ˆä¸Šæ•ˆæœï¼


![image](https://img2024.cnblogs.com/blog/271236/202409/271236-20240910160316380-1008738887.gif)
![image](https://img2024.cnblogs.com/blog/271236/202409/271236-20240910160323142-1760830900.gif)


å®ç°æ–¹å¼åŸºæœ¬å’Œ[ã€Šå‰ç«¯ä½¿ç”¨ Konva å®ç°å¯è§†åŒ–è®¾è®¡å™¨ï¼ˆ21ï¼‰\- ç»˜åˆ¶å›¾å½¢ï¼ˆæ¤­åœ†ï¼‰ã€‹](https://github.com)æ˜¯ä¸€è‡´çš„ï¼Œä¸»è¦åŒºåˆ«çŸ©å½¢çš„å¤§å°å’Œæ¤­åœ†å½¢çš„å¤§å°è®¾ç½®æ–¹å¼ä¸ä¸€æ ·ï¼Œç‰¹åˆ«æ˜¯çŸ©å½¢æ— éœ€è®¾ç½® offsetã€‚å…¶å®ƒå°±ä¸å†èµ˜è¿°äº†å“ˆã€‚


## ç›´çº¿ã€æŠ˜çº¿


å…ˆä¸Šæ•ˆæœï¼


![image](https://img2024.cnblogs.com/blog/271236/202409/271236-20240910160419465-830864575.gif)
![image](https://img2024.cnblogs.com/blog/271236/202409/271236-20240910160423789-371724923.gif)


ç®€å•æè¿°ä¸€ä¸‹ä¸Šé¢çš„äº¤äº’ï¼š


é¦–å…ˆï¼Œç»˜åˆ¶ä¸€æ¡ç›´çº¿ï¼Œæ·¡å‡ºç”»ä¸€æ¡ç›´çº¿è¿˜æ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œæ ¹æ®è®°å½•é¼ æ ‡æŒ‰ä¸‹çš„ä½ç½®å’Œé¼ æ ‡é‡Šæ”¾çš„ä½ç½®ï¼Œå°±å¾ˆå®¹æ˜“å¾—åˆ° Konva.Line çš„ points åº”è¯¥è®¾å®šçš„å€¼äº†ã€‚


ç„¶åï¼Œæ²¿ç”¨ç»˜åˆ¶ æ¤­åœ†å½¢ã€çŸ©å½¢ çš„æ€è·¯ï¼Œå®ƒåªæœ‰ç‰¹å®šçš„ 2 ä¸ªâ€œè°ƒæ•´ç‚¹â€ï¼Œåˆ†åˆ«ä»£è¡¨ èµ·ç‚¹ å’Œ ç»ˆç‚¹ã€‚



```
// src/Render/graphs/Line.ts

// ç•¥

/**
 * ç›´çº¿ã€æŠ˜çº¿
 */
export class Line extends BaseGraph {
  // ç•¥

  constructor(render: Types.Render, dropPoint: Konva.Vector2d) {
    super(render, dropPoint, {
      type: Types.GraphType.Line,
      // å®šä¹‰äº† 2 ä¸ª è°ƒæ•´ç‚¹
      anchors: [{ adjustType: 'start' }, { adjustType: 'end' }].map((o) => ({
        adjustType: o.adjustType // è°ƒæ•´ç‚¹ ç±»å‹å®šä¹‰
      })),
      linkAnchors: [
        { x: 0, y: 0, alias: 'start' },
        { x: 0, y: 0, alias: 'end' }
      ] as Types.AssetInfoPoint[]
    })

    // æ–°å»º ç›´çº¿ã€æŠ˜çº¿
    this.line = new Konva.Line({
      name: 'graph',
      x: 0,
      y: 0,
      stroke: 'black',
      strokeWidth: 1,
      hitStrokeWidth: render.toStageValue(5)
    })

    // ç»™äºˆ 1 åƒç´ ï¼Œé˜²æ­¢å¯¼å‡ºå›¾ç‰‡ toDataURL å¤±è´¥
    this.group.size({
      width: 1,
      height: 1
    })

    // åŠ å…¥
    this.group.add(this.line)
    // é¼ æ ‡æŒ‰ä¸‹ä½ç½® ä½œä¸ºèµ·ç‚¹
    this.group.position(this.dropPoint)
  }

  // å®ç°ï¼šæ‹–åŠ¨è¿›è¡Œæ—¶
  override drawMove(point: Konva.Vector2d): void {
    // é¼ æ ‡æ‹–åŠ¨åç§»é‡
    const offsetX = point.x - this.dropPoint.x,
      offsetY = point.y - this.dropPoint.y

    // èµ·ç‚¹ã€ç»ˆç‚¹
    const linkPoints = [
      [this.line.x(), this.line.y()],
      [this.line.x() + offsetX, this.line.y() + offsetY]
    ]

    // ç›´çº¿ã€æŠ˜çº¿ è·¯å¾„
    this.line.points(_.flatten(linkPoints))

    // æ›´æ–° å›¾å½¢ çš„ è°ƒæ•´ç‚¹ çš„ é”šç‚¹ä½ç½®
    Line.updateAnchorShadows(this.group, this.anchorShadows, this.line)

    // æ›´æ–° å›¾å½¢ çš„ è¿æ¥ç‚¹ çš„ é”šç‚¹ä½ç½®
    Line.updateLinkAnchorShadows(this.group, this.linkAnchorShadows, this.line)

    // é‡ç»˜
    this.render.redraw([Draws.GraphDraw.name, Draws.LinkDraw.name, Draws.PreviewDraw.name])
  }

  // å®ç°ï¼šæ‹–åŠ¨ç»“æŸ
  override drawEnd(): void {
    if (this.line.width() <= 1 && this.line.height() <= 1) {
      // åŠ å…¥åªç‚¹å‡»ï¼Œæ— æ‹–åŠ¨

      // é»˜è®¤å¤§å°
      const width = Line.size,
        height = width

      // èµ·ç‚¹ã€ç»ˆç‚¹
      const linkPoints = [
        [this.line.x(), this.line.y()],
        [this.line.x() + width, this.line.y() + height]
      ]

      // ç›´çº¿ã€æŠ˜çº¿ ä½ç½®å¤§å°
      this.line.points(_.flatten(linkPoints))
    }

    // æ›´æ–° è°ƒæ•´ç‚¹ï¼ˆæ‹ç‚¹ï¼‰
    Line.updateAnchor(this.render, this.group)

    // æ›´æ–° å›¾å½¢ çš„ è°ƒæ•´ç‚¹ çš„ é”šç‚¹ä½ç½®
    Line.updateAnchorShadows(this.group, this.anchorShadows, this.line)

    // æ›´æ–° å›¾å½¢ çš„ è¿æ¥ç‚¹ çš„ é”šç‚¹ä½ç½®
    Line.updateLinkAnchorShadows(this.group, this.linkAnchorShadows, this.line)

    // å¯¹é½çº¿æ¸…é™¤
    this.render.attractTool.alignLinesClear()

    // æ›´æ–°å†å²
    this.render.updateHistory()

    // é‡ç»˜
    this.render.redraw([Draws.GraphDraw.name, Draws.LinkDraw.name, Draws.PreviewDraw.name])
  }

  // ç•¥
}


```

è°ƒæ•´ç‚¹ï¼Œå¯ä»¥æ”¹å˜ ç›´çº¿ã€æŠ˜çº¿ çš„ èµ·ç‚¹ã€ç»ˆç‚¹ã€‚



```
// ç•¥

/**
 * ç›´çº¿ã€æŠ˜çº¿
 */
export class Line extends BaseGraph {
  // å®ç°ï¼šæ›´æ–° å›¾å½¢ çš„ è°ƒæ•´ç‚¹ çš„ é”šç‚¹ä½ç½®
  static override updateAnchorShadows(
    graph: Konva.Group,
    anchorShadows: Konva.Circle[],
    shape?: Konva.Line
  ): void {
    if (shape) {
      const points = shape.points()
      //
      for (const shadow of anchorShadows) {
        switch (shadow.attrs.adjustType) {
          case 'start':
            shadow.position({
              x: points[0],
              y: points[1]
            })
            break
          case 'end':
            shadow.position({
              x: points[points.length - 2],
              y: points[points.length - 1]
            })
            break
        }
      }
    }
  }
  
  // ç•¥

  // å®ç°ï¼šç”Ÿæˆ è°ƒæ•´ç‚¹
  static override createAnchorShapes(
    render: Types.Render,
    graph: Konva.Group,
    anchorAndShadows: {
      anchor: Types.GraphAnchor
      anchorShadow: Konva.Circle
      shape?: Konva.Shape
    }[],
    adjustAnchor?: Types.GraphAnchor
  ): {
    anchorAndShadows: {
      anchor: Types.GraphAnchor
      anchorShadow: Konva.Circle
      shape?: Konva.Shape | undefined
    }[]
  } {
    // stage çŠ¶æ€
    const stageState = render.getStageState()

    const graphShape = graph.findOne('.graph') as Konva.Line

    if (graphShape) {
      const points = graphShape.points()

      for (const anchorAndShadow of anchorAndShadows) {
        let rotate = 0
        const { anchor, anchorShadow } = anchorAndShadow

        const x = render.toStageValue(anchorShadow.getAbsolutePosition().x - stageState.x),
          y = render.toStageValue(anchorShadow.getAbsolutePosition().y - stageState.y)

        if (anchor.adjustType === 'manual') {
          // ç•¥
        } else {
          if (anchor.adjustType === 'start') {
            rotate = Line.calculateAngle(points[2] - points[0], points[3] - points[1])
          } else if (anchor.adjustType === 'end') {
            rotate = Line.calculateAngle(
              points[points.length - 2] - points[points.length - 4],
              points[points.length - 1] - points[points.length - 3]
            )
          }

          const cos = Math.cos((rotate * Math.PI) / 180)
          const sin = Math.sin((rotate * Math.PI) / 180)

          const offset = render.toStageValue(render.pointSize + 5)

          const offsetX = offset * sin
          const offsetY = offset * cos

          const anchorShape = new Konva.Circle({
            name: 'anchor',
            anchor: anchor,
            //
            fill:
              adjustAnchor?.adjustType === anchor.adjustType && adjustAnchor?.groupId === graph.id()
                ? 'rgba(0,0,255,0.8)'
                : 'rgba(0,0,255,0.2)',
            radius: render.toStageValue(3),
            strokeWidth: 0,
            // ä½ç½®
            x: x,
            y: y,
            offsetX:
              anchor.adjustType === 'start' ? offsetX : anchor.adjustType === 'end' ? -offsetX : 0,
            offsetY:
              anchor.adjustType === 'start' ? offsetY : anchor.adjustType === 'end' ? -offsetY : 0,
            // æ—‹è½¬è§’åº¦
            rotation: graph.getAbsoluteRotation()
          })

          anchorShape.on('mouseenter', () => {
            anchorShape.fill('rgba(0,0,255,0.8)')
            document.body.style.cursor = 'move'
          })
          anchorShape.on('mouseleave', () => {
            anchorShape.fill(
              anchorShape.attrs.adjusting ? 'rgba(0,0,255,0.8)' : 'rgba(0,0,255,0.2)'
            )
            document.body.style.cursor = anchorShape.attrs.adjusting ? 'move' : 'default'
          })

          anchorAndShadow.shape = anchorShape
        }
      }
    }

    return { anchorAndShadows }
  }

  // ç•¥

  // å®ç°ï¼šè°ƒæ•´ å›¾å½¢
  static override adjust(
    render: Types.Render,
    graph: Konva.Group,
    graphSnap: Konva.Group,
    adjustShape: Konva.Shape,
    anchorAndShadows: {
      anchor: Types.GraphAnchor
      anchorShadow: Konva.Circle
      shape?: Konva.Shape | undefined
    }[],
    startPoint: Konva.Vector2d,
    endPoint: Konva.Vector2d
  ) {
    // ç›®æ ‡ ç›´çº¿ã€æŠ˜çº¿
    const line = graph.findOne('.graph') as Konva.Line
    // é•œåƒ
    const lineSnap = graphSnap.findOne('.graph') as Konva.Line

    // è°ƒæ•´ç‚¹ é”šç‚¹
    const anchors = (graph.find('.anchor') ?? []) as Konva.Circle[]
    // é•œåƒ
    const anchorsSnap = (graphSnap.find('.anchor') ?? []) as Konva.Circle[]

    // è¿æ¥ç‚¹ é”šç‚¹
    const linkAnchors = (graph.find('.link-anchor') ?? []) as Konva.Circle[]

    if (line && lineSnap) {
      // stage çŠ¶æ€
      const stageState = render.getStageState()

      {
        const [graphRotation, adjustType, ex, ey] = [
          Math.round(graph.rotation()),
          adjustShape.attrs.anchor?.adjustType,
          endPoint.x,
          endPoint.y
        ]

        const { x: cx, y: cy, width: cw, height: ch } = graphSnap.getClientRect()

        const { x, y } = graph.position()

        const [centerX, centerY] = [cx + cw / 2, cy + ch / 2]

        const { x: sx, y: sy } = Line.rotatePoint(ex, ey, centerX, centerY, -graphRotation)
        const { x: rx, y: ry } = Line.rotatePoint(x, y, centerX, centerY, -graphRotation)

        const points = line.points()
        const manualPoints = (line.attrs.manualPoints ?? []) as Types.LineManualPoint[]

        if (adjustType === 'manual') {
          // ç•¥
        } else {
          const anchor = anchors.find((o) => o.attrs.adjustType === adjustType)
          const anchorShadow = anchorsSnap.find((o) => o.attrs.adjustType === adjustType)

          if (anchor && anchorShadow) {
            {
              const linkPoints = [
                [points[0], points[1]],
                ...manualPoints.sort((a, b) => a.index - b.index).map((o) => [o.x, o.y]),
                [points[points.length - 2], points[points.length - 1]]
              ]

              switch (adjustType) {
                case 'start':
                  {
                    linkPoints[0] = [sx - rx, sy - ry]
                    line.points(_.flatten(linkPoints))
                  }
                  break
                case 'end':
                  {
                    linkPoints[linkPoints.length - 1] = [sx - rx, sy - ry]
                    line.points(_.flatten(linkPoints))
                  }
                  break
              }
            }
          }
        }
      }

      // æ›´æ–° è°ƒæ•´ç‚¹ï¼ˆæ‹ç‚¹ï¼‰
      Line.updateAnchor(render, graph)

      // æ›´æ–° è°ƒæ•´ç‚¹ çš„ é”šç‚¹ ä½ç½®
      Line.updateAnchorShadows(graph, anchors, line)

      // æ›´æ–° å›¾å½¢ çš„ è¿æ¥ç‚¹ çš„ é”šç‚¹ä½ç½®
      Line.updateLinkAnchorShadows(graph, linkAnchors, line)

      // æ›´æ–° è°ƒæ•´ç‚¹ ä½ç½®
      for (const anchor of anchors) {
        for (const { shape } of anchorAndShadows) {
          if (shape) {
            if (shape.attrs.anchor?.adjustType === anchor.attrs.adjustType) {
              const anchorShadow = graph
                .find(`.anchor`)
                .find((o) => o.attrs.adjustType === anchor.attrs.adjustType)

              if (anchorShadow) {
                shape.position({
                  x: render.toStageValue(anchorShadow.getAbsolutePosition().x - stageState.x),
                  y: render.toStageValue(anchorShadow.getAbsolutePosition().y - stageState.y)
                })
                shape.rotation(graph.getAbsoluteRotation())
              }
            }
          }
        }
      }

      // é‡ç»˜
      render.redraw([Draws.GraphDraw.name, Draws.LinkDraw.name, Draws.PreviewDraw.name])
    }
  }

  // ç•¥
}


```

### æŠ˜çº¿


ç›¸æ¯”ç»˜åˆ¶ æ¤­åœ†å½¢ã€çŸ©å½¢ æ¯”è¾ƒä¸ä¸€æ ·çš„åœ°æ–¹åœ¨äºï¼Œæ¤­åœ†å½¢ã€çŸ©å½¢ çš„â€œè°ƒæ•´ç‚¹â€æ˜¯å›ºå®šçš„ï¼Œè€Œç»˜åˆ¶ æŠ˜çº¿ ä¸ä¸€æ ·ï¼Œæ²¡è°ƒæ•´ä¸€ä¸ªæ–°çš„æ‹ç‚¹ï¼Œå°±ä¼šæ–°å¢ 2 ä¸ªæ–°è°ƒæ•´ç‚¹ï¼Œæ•´ä½“äº¤äº’ä¸ æ‰‹åŠ¨è¿æ¥çº¿ ç±»ä¼¼ã€‚


![image](https://img2024.cnblogs.com/blog/271236/202409/271236-20240910160441189-2026784590.gif)



```
// src/Render/draws/GraphDraw.ts

// ç•¥

export interface GraphDrawState {
  // ç•¥

  /**
   * è°ƒæ•´ä¸­ è°ƒæ•´ç‚¹
   */
  adjustAnchor?: Types.GraphAnchor

  /**
   * é¼ æ ‡æŒ‰ä¸‹ è°ƒæ•´ç‚¹ ä½ç½®
   */
  startPointCurrent: Konva.Vector2d

  /**
   * å›¾å½¢ group
   */
  graphCurrent?: Konva.Group

  /**
   * å›¾å½¢ group é•œåƒï¼Œç”¨äºè®¡ç®—ä½ç½®ã€å¤§å°çš„åç§»
   */
  graphCurrentSnap?: Konva.Group
}

// ç•¥

export class GraphDraw extends Types.BaseDraw implements Types.Draw {
  // ç•¥

  state: GraphDrawState = {
    adjusting: false,
    adjustGroupId: '',
    startPointCurrent: { x: 0, y: 0 }
  }

  // ç•¥

  override draw() {
    this.clear()
    // æ‰€æœ‰å›¾å½¢
    const graphs = this.render.layer
      .find('.asset')
      .filter((o) => o.attrs.assetType === Types.AssetType.Graph) as Konva.Group[]

    for (const graph of graphs) {
      // éé€‰ä¸­çŠ¶æ€æ‰æ˜¾ç¤º è°ƒæ•´ç‚¹
      if (!graph.attrs.selected) {
        // ç•¥

        for (const anchorAndShadow of anchorAndShadows) {
          const { shape } = anchorAndShadow

          if (shape) {
            // é¼ æ ‡æŒ‰ä¸‹
            shape.on('mousedown', () => {
              const pos = this.getStagePoint()
              if (pos) {
                this.state.adjusting = true
                this.state.adjustAnchor = shape.attrs.anchor
                this.state.adjustGroupId = graph.id()

                this.state.startPointCurrent = pos

                this.state.graphCurrent = graph
                this.state.graphCurrentSnap = graph.clone()

                shape.setAttr('adjusting', true)

                if (this.state.adjustAnchor) {
                  switch (shape.attrs.anchor?.type) {
                    case Types.GraphType.Line:
                      // ä½¿ç”¨ ç›´çº¿ã€æŠ˜çº¿ é™æ€å¤„ç†æ–¹æ³•
                      Graphs.Line.adjustStart(this.render, graph, this.state.adjustAnchor, pos)
                      break
                  }
                }
              }
            })

            // ç•¥

            // è°ƒæ•´ç»“æŸ
            this.render.stage.on('mouseup', () => {
              // ç•¥
              
              this.state.adjusting = false
              this.state.adjustAnchor = undefined
              this.state.adjustGroupId = ''

              // æ¢å¤æ˜¾ç¤ºæ‰€æœ‰ è°ƒæ•´ç‚¹
              for (const { shape } of anchorAndShadows) {
                if (shape) {
                  shape.opacity(1)
                  shape.setAttr('adjusting', false)
                  if (shape.attrs.anchor?.type === Types.GraphType.Line) {
                    if (shape.attrs.anchor.adjusted) {
                      shape.fill('rgba(0,0,0,0.4)')
                    } else {
                      shape.fill('rgba(0,0,255,0.2)')
                    }
                  } else {
                    shape.stroke('rgba(0,0,255,0.2)')
                  }
                }

                // ç•¥
              }

              // ç•¥
            })

            // ç•¥
          }
        }
      }
    }
  }
}

```

ä¸Šé¢é™¤äº†éœ€è¦æ›´å¤šçš„çŠ¶æ€è®°å½• è°ƒæ•´ ä¿¡æ¯ï¼Œè¿˜éœ€è¦å®šä¹‰ Line ç‰¹æœ‰çš„ adjustStart æ–¹æ³•ï¼š



```
// src/Render/graphs/Line.ts

// ç•¥

/**
 * ç›´çº¿ã€æŠ˜çº¿
 */
export class Line extends BaseGraph {
  // ç•¥

  /**
   * è°ƒæ•´ä¹‹å‰
   */
  static adjustStart(
    render: Types.Render,
    graph: Konva.Group,
    adjustAnchor: Types.GraphAnchor & { manualIndex?: number; adjusted?: boolean },
    endPoint: Konva.Vector2d
  ) {
    const { x: gx, y: gy } = graph.position()

    const shape = graph.findOne('.graph') as Konva.Line

    if (shape && typeof adjustAnchor.manualIndex === 'number') {
      const manualPoints = (shape.attrs.manualPoints ?? []) as Types.LineManualPoint[]
      if (adjustAnchor.adjusted) {
        //
      } else {
        manualPoints.push({
          x: endPoint.x - gx,
          y: endPoint.y - gy,
          index: adjustAnchor.manualIndex
        })
        shape.setAttr('manualPoints', manualPoints)
      }

      // æ›´æ–° è°ƒæ•´ç‚¹ï¼ˆæ‹ç‚¹ï¼‰
      Line.updateAnchor(render, graph)
    }
  }
}

// ç•¥

```

åŠ¨æ€çš„è°ƒæ•´ç‚¹ï¼Œä¼šè®°å½•åœ¨ line çš„ attrs ä¸­ manualPointsï¼Œæ¯æ¬¡é¦–æ¬¡è°ƒæ•´ä¸€å¤„ æ‹ç‚¹ï¼Œå°±ä¼šæ–°å¢ä¸€ä¸ª æ–° æ‹ç‚¹ï¼Œä¸»è¦åº”ç”¨åœ¨ï¼š



```
// ç•¥

/**
 * ç›´çº¿ã€æŠ˜çº¿
 */
export class Line extends BaseGraph {
  // ç•¥

  // å®ç°ï¼šè°ƒæ•´ å›¾å½¢
  static override adjust(
    render: Types.Render,
    graph: Konva.Group,
    graphSnap: Konva.Group,
    adjustShape: Konva.Shape,
    anchorAndShadows: {
      anchor: Types.GraphAnchor
      anchorShadow: Konva.Circle
      shape?: Konva.Shape | undefined
    }[],
    startPoint: Konva.Vector2d,
    endPoint: Konva.Vector2d
  ) {
    // ç›®æ ‡ ç›´çº¿ã€æŠ˜çº¿
    const line = graph.findOne('.graph') as Konva.Line
    // é•œåƒ
    const lineSnap = graphSnap.findOne('.graph') as Konva.Line

    // è°ƒæ•´ç‚¹ é”šç‚¹
    const anchors = (graph.find('.anchor') ?? []) as Konva.Circle[]
    // é•œåƒ
    const anchorsSnap = (graphSnap.find('.anchor') ?? []) as Konva.Circle[]

    // è¿æ¥ç‚¹ é”šç‚¹
    const linkAnchors = (graph.find('.link-anchor') ?? []) as Konva.Circle[]

    if (line && lineSnap) {
      // stage çŠ¶æ€
      const stageState = render.getStageState()

      {
        const [graphRotation, adjustType, ex, ey] = [
          Math.round(graph.rotation()),
          adjustShape.attrs.anchor?.adjustType,
          endPoint.x,
          endPoint.y
        ]

        const { x: cx, y: cy, width: cw, height: ch } = graphSnap.getClientRect()

        const { x, y } = graph.position()

        const [centerX, centerY] = [cx + cw / 2, cy + ch / 2]

        const { x: sx, y: sy } = Line.rotatePoint(ex, ey, centerX, centerY, -graphRotation)
        const { x: rx, y: ry } = Line.rotatePoint(x, y, centerX, centerY, -graphRotation)

        const points = line.points()
        const manualPoints = (line.attrs.manualPoints ?? []) as Types.LineManualPoint[]

        if (adjustType === 'manual') {
          if (adjustShape.attrs.anchor?.manualIndex !== void 0) {
            const index = adjustShape.attrs.anchor?.adjusted
              ? adjustShape.attrs.anchor?.manualIndex
              : adjustShape.attrs.anchor?.manualIndex + 1

            const manualPointIndex = manualPoints.findIndex((o) => o.index === index)

            if (manualPointIndex > -1) {
              manualPoints[manualPointIndex].x = sx - rx
              manualPoints[manualPointIndex].y = sy - ry
            }

            const linkPoints = [
              [points[0], points[1]],
              ...manualPoints.sort((a, b) => a.index - b.index).map((o) => [o.x, o.y]),
              [points[points.length - 2], points[points.length - 1]]
            ]

            line.setAttr('manualPoints', manualPoints)

            line.points(_.flatten(linkPoints))

            //
            const adjustAnchorShadow = anchors.find(
              (o) => o.attrs.adjustType === 'manual' && o.attrs.manualIndex === index
            )
            if (adjustAnchorShadow) {
              adjustAnchorShadow.position({
                x: sx - rx,
                y: sy - ry
              })
            }
          }
        } else {
          // ç•¥
        }
      }

      // ç•¥
    }
  }

  // ç•¥

  /**
   * æ›´æ–° è°ƒæ•´ç‚¹ï¼ˆæ‹ç‚¹ï¼‰
   * @param render
   * @param graph
   */
  static updateAnchor(render: Types.Render, graph: Konva.Group) {
    const anchors = graph.attrs.anchors ?? []
    const anchorShadows = graph.find('.anchor') ?? []

    const shape = graph.findOne('.graph') as Konva.Line

    if (shape) {
      // å·²æ‹
      let manualPoints = (shape.attrs.manualPoints ?? []) as Types.LineManualPoint[]
      const points = shape.points()

      // è°ƒæ•´ç‚¹ + æ‹ç‚¹
      const linkPoints = [
        [points[0], points[1]],
        ...manualPoints.sort((a, b) => a.index - b.index).map((o) => [o.x, o.y]),
        [points[points.length - 2], points[points.length - 1]]
      ]

      // æ¸…ç©º è°ƒæ•´ç‚¹ï¼ˆæ‹ç‚¹ï¼‰,ä¿ç•™ start end
      anchors.splice(2)
      const shadows = anchorShadows.splice(2)
      for (const shadow of shadows) {
        shadow.remove()
        shadow.destroy()
      }

      manualPoints = []

      for (let i = linkPoints.length - 1; i > 0; i--) {
        linkPoints.splice(i, 0, [])
      }

      // è°ƒæ•´ç‚¹ï¼ˆæ‹ç‚¹ï¼‰
      for (let i = 1; i < linkPoints.length - 1; i++) {
        const anchor = {
          type: graph.attrs.graphType,
          adjustType: 'manual',
          //
          name: 'anchor',
          groupId: graph.id(),
          //
          manualIndex: i,
          adjusted: false
        }

        if (linkPoints[i].length === 0) {
          anchor.adjusted = false

          // æ–°å¢
          const prev = linkPoints[i - 1]
          const next = linkPoints[i + 1]

          const circle = new Konva.Circle({
            adjustType: anchor.adjustType,
            anchorType: anchor.type,
            name: anchor.name,
            manualIndex: anchor.manualIndex,
            radius: 0,
            // radius: render.toStageValue(2),
            // fill: 'red',
            //
            x: (prev[0] + next[0]) / 2,
            y: (prev[1] + next[1]) / 2,
            anchor
          })

          graph.add(circle)
        } else {
          anchor.adjusted = true

          // å·²æ‹
          const circle = new Konva.Circle({
            adjustType: anchor.adjustType,
            anchorType: anchor.type,
            name: anchor.name,
            manualIndex: anchor.manualIndex,
            adjusted: true,
            radius: 0,
            // radius: render.toStageValue(2),
            // fill: 'red',
            //
            x: linkPoints[i][0],
            y: linkPoints[i][1],
            anchor
          })

          graph.add(circle)

          manualPoints.push({
            x: linkPoints[i][0],
            y: linkPoints[i][1],
            index: anchor.manualIndex
          })
        }

        anchors.push(anchor)
      }

      shape.setAttr('manualPoints', manualPoints)

      graph.setAttr('anchors', anchors)
    }
  }

  // ç•¥
}


```

ä¸Šé¢ç®€å•çš„è¯´ï¼Œå°±æ˜¯å¤„ç† manualPoints çš„ç®—æ³•ï¼Œè´Ÿè´£æ§åˆ¶æ–°å¢æ‹ç‚¹ï¼Œç„¶åæŠŠâ€œç‚¹â€ä»¬æ’å…¥åˆ° èµ·ç‚¹ã€ç»ˆç‚¹ ä¹‹é—´ï¼Œæœ€åå¤„ç†æˆ Konva.Line çš„ points çš„å€¼ã€‚


é¡ºå¸¦ä¸€è¯´ã€‚åŒºåˆ† èµ·ç‚¹ã€ç»ˆç‚¹ å’Œ æ‹ç‚¹ æ˜¯é€šè¿‡ attrs ä¸­çš„ adjustType å­—æ®µï¼›åŒºåˆ† æ‹ç‚¹ æ˜¯å¦å·²ç»æ“ä½œè¿‡ æ˜¯é€šè¿‡ attrs ä¸­çš„ adjusted å­—æ®µï¼›æ‹ç‚¹æ˜¯å­˜åœ¨æ˜ç¡®çš„é¡ºåºçš„ï¼Œä¼šè®°å½•åœ¨ attrs çš„ manualIndex å­—æ®µä¸­ã€‚



> ä¸ªäººè§‰å¾—ï¼Œç›®å‰ï¼Œç»˜åˆ¶å›¾å½¢çš„ ä»£ç ç»“æ„ å’Œ å˜é‡å‘½å å®¹æ˜“äº§ç”Ÿæ­§ä¹‰ï¼Œåé¢å°½é‡æŠ½å‡ºæ—¶é—´é‡æ„ä¸€ä¸‹ï¼Œå¤§å®¶æ”¯æŒæ”¯æŒ ğŸ‘‡ï¼


Thanks watching\~



> More Stars pleaseï¼å‹¾å‹¾æ‰‹æŒ‡\~
> 
> 
> [æºç ](https://github.com)
> 
> 
> [giteeæºç ](https://github.com)
> 
> 
> [ç¤ºä¾‹åœ°å€](https://github.com)


